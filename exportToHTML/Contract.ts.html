<html>
<head>
<title>Contract.ts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #629755; font-weight: bold; font-style: italic;}
.s4 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
Contract.ts</font>
</center></td></tr></table>
<pre><span class="s0">/**</span>
 <span class="s0">* API to access the blockchain and the contract.</span>
 <span class="s0">* TODO: The actual implementation is not yet available. Create and use mock data.</span>
 <span class="s0">*/</span>
<span class="s2">interface </span><span class="s1">Application {</span>
    <span class="s0">/**</span>
     <span class="s0">* Initiates the process to connect a wallet. Will do nothing if a wallet is already connected</span>
     <span class="s0">*/</span>
    <span class="s1">connectWallet: () =&gt; Promise&lt;</span><span class="s2">void</span><span class="s1">&gt;</span><span class="s2">;</span>

    <span class="s0">/**</span>
     <span class="s0">* Returns true if the wallet has been connected, false otherwise</span>
     <span class="s0">*/</span>
    <span class="s1">isWalletConnected: () =&gt; Promise&lt;boolean&gt;</span><span class="s2">;</span>

    <span class="s0">/**</span>
     <span class="s0">* The address of the current wallet or throws an error if no wallet has been connected</span>
     <span class="s0">*/</span>
    <span class="s1">walletAddress: () =&gt; Promise&lt;string&gt;</span><span class="s2">;</span>

    <span class="s0">/**</span>
     <span class="s0">* Returns true if the contract has been deployed and is ready, i.e. the auction has been started</span>
     <span class="s0">*/</span>
    <span class="s1">isContractReady: () =&gt; Promise&lt;boolean&gt;</span><span class="s2">;</span>

    <span class="s0">/**</span>
     <span class="s0">* Returns the contract if it is ready and a wallet has been connected or throws an error</span>
     <span class="s0">*/</span>
    <span class="s1">blockchain: () =&gt; Promise&lt;Contract&gt;</span><span class="s2">;</span>

    <span class="s0">/**</span>
     <span class="s0">* Returns the bronze utilities. Throws an error if no wallet is connected.</span>
     <span class="s0">*/</span>
    <span class="s1">bronzeUtilities: () =&gt; Promise&lt;BronzeUtilities&gt;</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s0">/**</span>
 <span class="s0">* Represents the functions available for the bronze utilities</span>
 <span class="s0">*/</span>
<span class="s2">interface </span><span class="s1">BronzeUtilities {</span>
    <span class="s0">/**</span>
     <span class="s0">* Returns true of the connected wallet has at least one token with bronze level or higher</span>
     <span class="s0">*/</span>
    <span class="s1">hasAccess: () =&gt; Promise&lt;boolean&gt;</span><span class="s2">;</span>

    <span class="s0">/**</span>
     <span class="s0">* Returns a list of categories containing files available for download</span>
     <span class="s0">*/</span>
    <span class="s1">categories: () =&gt; Promise&lt;FileCategory[]&gt;</span><span class="s2">;</span>

    <span class="s0">/**</span>
     <span class="s0">* Downloads a given file. Throws an error if file does not exist</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">fileName</span>
     <span class="s0">*/</span>
    <span class="s1">download: (fileName: string) =&gt; Promise&lt;</span><span class="s2">void</span><span class="s1">&gt;</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s0">/**</span>
 <span class="s0">* Represents a category of files in the bronze utilities</span>
 <span class="s0">*/</span>
<span class="s2">interface </span><span class="s1">FileCategory {</span>
    <span class="s1">title: string</span><span class="s2">;</span>
    <span class="s1">files: FileData[]</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s0">/**</span>
 <span class="s0">* Represents a file in the bronze utilities</span>
 <span class="s0">*/</span>
<span class="s2">interface </span><span class="s1">FileData {</span>
    <span class="s1">name: string</span><span class="s2">;</span>

    <span class="s0">/**</span>
     <span class="s0">* Downloads the file (Same as calling {</span><span class="s3">@link </span><span class="s0">BronzeUtilities#download(name)}</span>
     <span class="s0">*/</span>
    <span class="s1">download: () =&gt; Promise&lt;</span><span class="s2">void</span><span class="s1">&gt;</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s0">/**</span>
 <span class="s0">* Represents the public available functions of the contract</span>
 <span class="s0">*/</span>
<span class="s2">interface </span><span class="s1">Contract {</span>
    <span class="s0">/**</span>
     <span class="s0">* The private auction API</span>
     <span class="s0">*/</span>
    <span class="s1">privateAuction: Auction</span><span class="s2">;</span>

    <span class="s0">/**</span>
     <span class="s0">* The public action API</span>
     <span class="s0">*/</span>
    <span class="s1">publicAuction: Auction</span><span class="s2">;</span>

    <span class="s0">/**</span>
     <span class="s0">* Returns true if all the tokens have been minted.</span>
     <span class="s0">*/</span>
    <span class="s1">minted: () =&gt; Promise&lt;boolean&gt;</span><span class="s2">;</span>

    <span class="s0">/**</span>
     <span class="s0">* Returns true if the metadata of the tokens have been revealed</span>
     <span class="s0">*/</span>
    <span class="s1">revealed: () =&gt; Promise&lt;boolean&gt;</span><span class="s2">;</span>

    <span class="s0">/**</span>
     <span class="s0">* Returns the metadata of the given token.</span>
     <span class="s0">* Throws an exception if the token does not exist.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">token the id of the token</span>
     <span class="s0">*/</span>
    <span class="s1">metadata: (token: number) =&gt; Promise&lt;Metadata&gt;</span><span class="s2">;</span>

    <span class="s1">staking: Staking</span><span class="s2">;</span>

    <span class="s0">/**</span>
     <span class="s0">* Returns the total amount of tickets for the currently connected wallet</span>
     <span class="s0">*/</span>
    <span class="s1">tickets: () =&gt; Promise&lt;number&gt;</span><span class="s2">;</span>

    <span class="s0">/**</span>
     <span class="s0">* Returns a list of tokens currently owned by the connected wallet</span>
     <span class="s0">*/</span>
    <span class="s1">tokens: () =&gt; Promise&lt;number[]&gt;</span><span class="s2">;</span>

    <span class="s0">/**</span>
     <span class="s0">* Returns true of the connected wallet is whitelisted</span>
     <span class="s0">*/</span>
    <span class="s1">whitelisted: () =&gt; Promise&lt;boolean&gt;</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s0">/**</span>
 <span class="s0">* Represents the metadata of a token</span>
 <span class="s0">*/</span>
<span class="s2">interface </span><span class="s1">Metadata {</span>
    <span class="s1">name: string</span><span class="s2">;</span>
    <span class="s1">description: string</span><span class="s2">;</span>
    <span class="s1">image: string</span><span class="s2">;</span>
    <span class="s1">external_url: string</span><span class="s2">;</span>
    <span class="s1">attributes: Attribute[]</span><span class="s2">;</span>
    <span class="s1">properties: Property[]</span><span class="s2">;</span>
    <span class="s4">// TBD</span>
<span class="s1">}</span>

<span class="s2">interface </span><span class="s1">Attribute {</span>
    <span class="s4">// TBD</span>
<span class="s1">}</span>

<span class="s2">interface </span><span class="s1">Property {</span>
    <span class="s4">// TBD</span>
<span class="s1">}</span>

<span class="s0">/**</span>
 <span class="s0">* Represents the staking process of the contract</span>
 <span class="s0">*/</span>
<span class="s2">interface </span><span class="s1">Staking {</span>
    <span class="s0">/**</span>
     <span class="s0">* Stakes the given token. Throws an error if the token is already staked or not owned by the connected wallet</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">token the id of the token</span>
     <span class="s0">*/</span>
    <span class="s1">stake: (token: number) =&gt; Promise&lt;</span><span class="s2">void</span><span class="s1">&gt;</span><span class="s2">;</span>

    <span class="s0">/**</span>
     <span class="s0">* Returns true if the given token is staked</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">token the id of the token</span>
     <span class="s0">*/</span>
    <span class="s1">staked: (token: number) =&gt; Promise&lt;boolean&gt;</span><span class="s2">;</span>

    <span class="s0">/**</span>
     <span class="s0">* Unstakes the given token. Throws an error if the token is not staked or not owned by the connected wallet</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">token the id of the token</span>
     <span class="s0">*/</span>
    <span class="s1">unStake: (token: number) =&gt; Promise&lt;</span><span class="s2">void</span><span class="s1">&gt;</span><span class="s2">;</span>

    <span class="s0">/**</span>
     <span class="s0">* Returns the current stake level of the token.</span>
     <span class="s0">* The returned value also reflects the level reached of the token is still staked.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">token the id of the token</span>
     <span class="s0">*/</span>
    <span class="s1">stakeLevel: (token: number) =&gt; Promise&lt;number&gt;</span><span class="s2">;</span>

    <span class="s0">/**</span>
     <span class="s0">* Returns the time for which the token has been staked</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">token</span>
     <span class="s0">*/</span>
    <span class="s1">stakeTime: (token: number) =&gt; Promise&lt;number&gt;</span><span class="s2">;</span>

    <span class="s0">/**</span>
     <span class="s0">* Returns a list of the durations in seconds to reach a level.</span>
     <span class="s0">* Example:</span>
     <span class="s0">* [0]: 3600 =&gt; 3600 seconds to level 1</span>
     <span class="s0">* [1]: 7200 =&gt; 7200 seconds to level 2</span>
     <span class="s0">*/</span>
    <span class="s1">stakeLevels: () =&gt; Promise&lt;number[]&gt;</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s0">/**</span>
 <span class="s0">* Represents the auction process of the contract</span>
 <span class="s0">*/</span>
<span class="s2">interface </span><span class="s1">Auction {</span>
    <span class="s0">/**</span>
     <span class="s0">* Buys the given amount of tickets.</span>
     <span class="s0">* </span><span class="s3">@param </span><span class="s0">amount the amount to buy</span>
     <span class="s0">* </span><span class="s3">@throws </span><span class="s0">If the wallet does not have enough funds</span>
     <span class="s0">* </span><span class="s3">@throws </span><span class="s0">If the wallet already has more than the maximum allowed tickets</span>
     <span class="s0">* </span><span class="s3">@throws </span><span class="s0">If the amount is 0</span>
     <span class="s0">* </span><span class="s3">@throws </span><span class="s0">If the amount if bigger than the maximum allowed tickets per wallet</span>
     <span class="s0">*/</span>
    <span class="s1">buy: (amount: number) =&gt; Promise&lt;</span><span class="s2">void</span><span class="s1">&gt;</span><span class="s2">;</span>

    <span class="s0">/**</span>
     <span class="s0">* Returns true if the auction has started</span>
     <span class="s0">*/</span>
    <span class="s1">hasStarted: () =&gt; Promise&lt;boolean&gt;</span><span class="s2">;</span>

    <span class="s0">/**</span>
     <span class="s0">* Returns true if the auction has been started, has tickets left and has not been stopped</span>
     <span class="s0">*/</span>
    <span class="s1">isActive: () =&gt; Promise&lt;boolean&gt;</span><span class="s2">;</span>

    <span class="s0">/**</span>
     <span class="s0">* Returns true of the auction has been stopped by the owner</span>
     <span class="s0">*/</span>
    <span class="s1">hasStopped: () =&gt; Promise&lt;boolean&gt;</span><span class="s2">;</span>

    <span class="s0">/**</span>
     <span class="s0">* Returns the tickets bought in the current auction by the connected wallet</span>
     <span class="s0">*/</span>
    <span class="s1">tickets: () =&gt; Promise&lt;number&gt;</span><span class="s2">;</span>

    <span class="s0">/**</span>
     <span class="s0">* Returns the tickets bought by all participants of the current auction</span>
     <span class="s0">*/</span>
    <span class="s1">ticketCount: () =&gt; Promise&lt;number&gt;</span><span class="s2">;</span>

    <span class="s0">/**</span>
     <span class="s0">* Returns the total ticket supply of the current auction</span>
     <span class="s0">*/</span>
    <span class="s1">ticketSupply: () =&gt; Promise&lt;number&gt;</span><span class="s2">;</span>

    <span class="s0">/**</span>
     <span class="s0">* Returns the maximum allowed tickets per wallet</span>
     <span class="s0">*/</span>
    <span class="s1">ticketLimit: () =&gt; Promise&lt;number&gt;</span><span class="s2">;</span>
<span class="s1">}</span></pre>
</body>
</html>